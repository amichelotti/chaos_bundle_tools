#!/bin/bash
curr=`pwd -P`
outdir=$curr
startdir=$1
pname="UnitServer"


lista_cu=();

lista_driver=();
lista_h=();
lista_lib=""
while getopts i:o:n:h opt; do
    case $opt in
	i) startdir=$OPTARG
	    ;;
	o) outdir=$OPTARG
	    ;;
	n) pname=$OPTARG
	    ;;
	h) echo "Usage : $0 [-i <input directory>] [-o <output directory>] [-n <project name>]"
	    exit 0
	    ;;
    esac
   
done
if ! [[ "$outdir" =~ ^/ ]] ; then
    outdir=$curr/$outdir
    
fi
pushd $startdir > /dev/null
listacpp=`find . -name "*.cpp"`;
listah=`find . -name "*.h"`;
project_dir=$outdir/$pname
echo "* creating $project_dir"
mkdir -p $project_dir


for c in $listah; do
    cu=`grep -s PUBLISHABLE_CONTROL_UNIT_INTERFACE $c | sed s/PUBLISHABLE_CONTROL_UNIT_INTERFACE/REGISTER_CU/`;
    header=`echo $c | sed 's/\/src//' | sed 's/\/source//' | sed s/\./$rr/`;
    filenamespace=""
    namespace=`egrep "namespace\ +\w+\ *\{" $c| cut -d ' ' -f 1`;
    echo "--->$namespace"
    for n in $namespace; do
	filenamespace="$filenamespace::$n";
    # if [[ "$n" =~ namespace\s+(\w+)\s*\{ ]]; then
    # 	filenamespace="$filenamespace::$BASH_REMATCH[1]";
    # 	echo "->$filenamespace"
    # fi
    done;

    plugin=`grep ADD_CU_DRIVER_PLUGIN_SUPERCLASS $c -s`;
    if [ -n "$plugin" ]; then
	echo "$c -> $filenamespace -> $plugin"
	if [[ "$plugin" =~ class\ +(.+)\: ]]; then
	    lista_driver+=("$filenamespace::${BASH_REMATCH[1]}");

	fi
    fi
    if [ -n "$cu" ]; then
	lista_cu+=("$cu");
	lista_h+=("$header");
    fi
done
# for c in $listacpp; do

#     drv=`grep -s REGISTER_PLUGIN\( $c | sed s/REGISTER_PLUGIN\(/REGISTER_DRIVER\(/`;
#     rr=`basename $startdir`


#     if [ -n "$drv" ]; then
# 	lista_driver+=("$drv");
# 	lista_h+=("$header");
#     fi
# done;

listcmake=`find . -name "CMakeLists.txt"`;
for c in $listcmake;do
    varl=`grep -i add_library $c | grep SHARED`;
    for var in $varl; do
	if [ -n "$var" ]; then
	    if [[ "$var" =~ .+\((.+) ]];then
		if [ -n "${BASH_REMATCH[1]}" ];then
		    lista_lib="$lista_lib ${BASH_REMATCH[1]}";
		fi
	    fi
	fi;
    done;
done;
echo -e "// Unit Server that includes the available CU in $startdir\n" > $project_dir/main.cpp
echo -e "// generated by $0\n\n" >> $project_dir/main.cpp
echo -e "#include <chaos/common/chaos_constants.h>\n#include <chaos/cu_toolkit/ChaosCUToolkit.h>\n#include <chaos/common/exception/CException.h>\n" >> $project_dir/main.cpp

for h in ${lista_h[@]};do
    
    echo "#include<$h>" >> $project_dir/main.cpp
done

echo -e "\n\nint main(int argc,char**argv){">>$project_dir/main.cpp
echo -e "\ttry{\n">>$project_dir/main.cpp
echo -e "\t\tchaos::cu::ChaosCUToolkit::getInstance()->init(argc, argv);">>$project_dir/main.cpp
for c in ${lista_cu[@]}; do
    echo -e "\t\t$c;" >> $project_dir/main.cpp
done
for c in ${lista_driver[@]}; do
    echo -e "\t\tREGISTER_DRIVER($c);" >> $project_dir/main.cpp
done
echo -e "\t\tchaos::cu::ChaosCUToolkit::getInstance()->start();" >> $project_dir/main.cpp

echo -e "\t} catch (CException& e) {\n\t\tstd::cerr<<\"Exception:\"<<std::endl;\n\t\tstd::cerr<< \"domain	:\"<<e.errorDomain << std::endl;\n\t\tstd::cerr<< \"cause	:\"<<e.errorMessage << std::endl;\n\t} catch (program_options::error &e){\n\t\tstd::cerr << "\"Unable to parse command line: \"" << e.what() << std::endl;\n\t} catch (...){\n\t\tstd::cerr << \"unexpected exception caught.. \" << std::endl;\n\t}\n}\n" >> $project_dir/main.cpp

echo "cmake_minimum_required(VERSION 2.6)" > $project_dir/CMakeLists.txt
echo "include(\$ENV{CHAOS_BUNDLE}/tools/project_template/CMakeChaos.txt)" >>  $project_dir/CMakeLists.txt
echo "SET(src main.cpp )" >>  $project_dir/CMakeLists.txt

echo "ADD_EXECUTABLE($pname \${src})" >>  $project_dir/CMakeLists.txt
echo "TARGET_LINK_LIBRARIES($pname $lista_lib chaos_cutoolkit chaos_common  \${FrameworkLib})" >>  $project_dir/CMakeLists.txt
echo "INSTALL_TARGETS(/bin $pname)" >>  $project_dir/CMakeLists.txt

popd > /dev/null
